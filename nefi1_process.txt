Presenter.py
run()
    algorithms = get_algorithms() <-- Guided Watershed with adaptive threshold <function guided_watershed_deletion_erosion_adaptive_threshold at 0x7fa99e730938>
                                        Median Blur + Bilateral Filter <function median_blur_bilateral_filter at 0x7fa99debab18>
                                        Invert Color <function invert_color at 0x7fa99deba7d0>
                                        Otsus Threshold <function otsus_threshold at 0x7fa99e730b90>
# img = cv2.imread(image, cv2.CV_LOAD_IMAGE_COLOR)
# results = algorithms[method](last_result, **parameters)

-->
ImageSegmentationCollection.py
        __algorithms__()
# def otsus_threshold(src, color_dict=None):
#    return SA.segment(src, marker_strategy=get_strategy(SA.null_marker, image=src), masking_strategy=SA.otsus_threshold)

-->
SegmentationAlgorithms.py as SA
    SA.segment()
# def segment(image, marker_strategy, masking_strategy):
#    marker = marker_strategy(image=image)
#    mask = masking_strategy(image=image, marker=marker)
#    return apply_mask_to_image(mask, image)


##########################################
Presenter.run()
    --> ImageSegmentationCollection.__algorithms__()
        --> otsus_threshold()
            --> SA.segment(src, marker_strategy=SA.get_strategy(SA.null_marker, image=src), masking_strategy=SA.otsus_threshold))

SA.otsus_threshold(image, threshold_value=0, threshold_type=cv.THRESH_BINARY_INV, **_):
    threshold_type += cv.THRESH_OTSU
    return constant_threshold(image, threshold_value, threshold_type)

SA.segment(src, marker_strategy=SA.get_strategy(SA.null_marker, image=src), masking_strategy=SA.otsus_threshold))

def segment(image, marker_strategy, SA.otsus_threshold):
    marker = marker_strategy(image=image) <-- is just an image array not gray
    mask = masking_strategy(image=image, marker=marker) <-- image processed by cv.constant_threshold()
    return apply_mask_to_image(mask, image)

def apply_mask_to_image(mask, image):
    """
    Constructs the segmented image based on the original image and the mask.

    Args:
        image: An input image which is not altered
        mask: A mask containing foreground and background information
    Returns:
         A segmented image
    """
    res = np.zeros_like(image)
    res[mask == THRESHOLD_FG_COLOR] = [THRESHOLD_FG_COLOR]*3

    return res
